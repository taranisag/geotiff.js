{"version":3,"sources":["../node_modules/regenerator-runtime/runtime.js","../node_modules/@babel/runtime/regenerator/index.js","../node_modules/@babel/runtime/helpers/defineProperty.js","../node_modules/@babel/runtime/helpers/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/nonIterableRest.js","../node_modules/@babel/runtime/helpers/slicedToArray.js","../node_modules/@babel/runtime/helpers/asyncToGenerator.js","../node_modules/@babel/runtime/helpers/createClass.js","../node_modules/@babel/runtime/helpers/setPrototypeOf.js","../node_modules/@babel/runtime/helpers/inherits.js","../node_modules/@babel/runtime/helpers/typeof.js","../node_modules/@babel/runtime/helpers/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","../node_modules/@babel/runtime/helpers/getPrototypeOf.js","../node_modules/@babel/runtime/helpers/isNativeFunction.js","../node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js","../node_modules/@babel/runtime/helpers/construct.js","../node_modules/@babel/runtime/helpers/wrapNativeSuper.js","../node_modules/@babel/runtime/helpers/classCallCheck.js","globals.js","rgb.js","predictor.js","compression/basedecoder.js","compression/raw.js","compression/lzw.js","compression/jpeg.js","compression/packbits.js","compression/index.js","resample.js","geotiffimage.js","dataview64.js","dataslice.js","source-rn.js","utils.js","geotiffwriter.js","logging.js","geotiff.js"],"names":["fieldTagNames","fieldTags","key","hasOwnProperty","parseInt","fieldTagTypes","arrayFields","BitsPerSample","ExtraSamples","SampleFormat","StripByteCounts","StripOffsets","StripRowCounts","TileByteCounts","TileOffsets","fieldTypeNames","fieldTypes","photometricInterpretations","WhiteIsZero","BlackIsZero","RGB","Palette","TransparencyMask","CMYK","YCbCr","CIELab","ICCLab","ExtraSamplesValues","Unspecified","Assocalpha","Unassalpha","geoKeyNames","geoKeys","fromWhiteIsZero","raster","max","width","value","height","rgbRaster","Uint8Array","i","j","length","fromBlackIsZero","fromPalette","colorMap","greenOffset","blueOffset","mapIndex","fromCMYK","cmykRaster","c","m","y","k","fromYCbCr","yCbCrRaster","Uint8ClampedArray","cb","cr","Xn","Yn","Zn","fromCIELab","cieLabRaster","L","x","z","r","g","b","Math","min","decodeRowAcc","row","stride","offset","decodeRowFloatingPoint","bytesPerSample","count","index","wc","copy","slice","applyPredictor","block","predictor","bitsPerSample","planarConfiguration","Error","byteLength","Uint16Array","Uint32Array","decoded","BaseDecoder","fileDirectory","buffer","decodeBlock","Predictor","isTiled","tileWidth","TileWidth","ImageWidth","tileHeight","TileLength","RowsPerStrip","ImageLength","PlanarConfiguration","RawDecoder","MIN_BITS","CLEAR_CODE","EOI_CODE","MAX_BYTELENGTH","getByte","array","position","d","a","floor","de","ef","fg","dg","console","warn","chunk1","chunks","chunk2","hi","appendReversed","dest","source","push","decompress","input","dictionaryIndex","dictionaryChar","dictionaryLength","initDictionary","getNext","byte","addToDictionary","getDictionaryReversed","n","rev","result","code","oldCode","val","oldVal","undefined","LZWDecoder","dctZigZag","Int32Array","dctCos1","dctSin1","dctCos3","dctSin3","dctCos6","dctSin6","dctSqrt2","dctSqrt1d2","buildHuffmanTable","codeLengths","values","children","p","q","pop","decodeScan","data","initialOffset","frame","components","resetInterval","spectralStart","spectralEnd","successivePrev","successive","mcusPerLine","progressive","startOffset","bitsData","bitsCount","readBit","nextByte","toString","decodeHuffman","tree","node","bit","receive","initialLength","receiveAndExtend","eobrun","successiveACState","successiveACNextValue","decodeMcu","component","decodeFunction","mcu","col","mcuRow","mcuCol","blockRow","v","blockCol","h","blocks","blocksPerLine","componentsLength","decodeFn","decodeDCFirst","zz","t","huffmanTableDC","diff","pred","decodeDCSuccessive","decodeACFirst","e","rs","huffmanTableAC","s","decodeACSuccessive","direction","decodeBaseline","marker","mcuExpected","blocksPerColumn","mcusPerColumn","usedResetInterval","buildComponentData","lines","samplesPerLine","R","quantizeAndInverse","dataOut","dataIn","qt","v0","v1","v2","v3","v4","v5","v6","v7","quantizationTable","sample","scanLine","line","JpegStreamReader","jfif","adobe","quantizationTables","huffmanTablesAC","huffmanTablesDC","resetFrames","frames","readUint16","prepareComponents","maxH","componentId","maxV","ceil","scanLines","blocksPerLineForMcu","blocksPerColumnForMcu","fileMarker","appData","subarray","version","major","minor","densityUnits","xDensity","yDensity","thumbWidth","thumbHeight","thumbData","flags0","flags1","transformCode","quantizationTablesLength","quantizationTablesEnd","quantizationTableSpec","tableData","extended","precision","componentsOrder","componentsCount","qId","quantizationIdx","huffmanLength","huffmanTableSpec","codeLengthSum","huffmanValues","selectorsCount","tableSpec","successiveApproximation","processed","Object","cp","keys","outComponents","scaleX","scaleY","out","oi","JpegDecoder","reader","JPEGTables","parse","getResult","PackbitsDecoder","dataView","DataView","header","getInt8","next","getUint8","getDecoder","Compression","copyNewSize","samplesPerPixel","getPrototypeOf","resampleNearest","valueArrays","inWidth","inHeight","outWidth","outHeight","relX","relY","map","newArray","cy","round","cx","lerp","resampleBilinear","rawY","yl","yh","rawX","tx","xl","xh","ll","hl","lh","hh","resample","method","toLowerCase","resampleNearestInterleaved","valueArray","samples","resampleBilinearInterleaved","resampleInterleaved","GeoTIFFImage","sum","start","end","arrayForType","format","size","Int8Array","Int16Array","Float32Array","Float64Array","littleEndian","cache","tiles","SamplesPerPixel","getWidth","getHeight","bits","RangeError","sampleIndex","prototype","getUint16","getUint32","getInt16","getInt32","getFloat32","getFloat64","poolOrDecoder","numTilesPerRow","getTileWidth","numTilesPerCol","getTileHeight","byteCount","fetch","request","decode","imageWindow","interleave","resampleMethod","minXTile","maxXTile","minYTile","maxYTile","windowWidth","bytesPerPixel","getBytesPerPixel","srcSampleOffsets","sampleReaders","getReaderForSample","yTile","promises","xTile","si","getSampleByteSize","promise","getTileOrStrip","then","tile","firstLine","firstCol","lastLine","lastCol","ymax","xmax","pixelOffset","call","windowCoordinate","Promise","all","resampled","wnd","window","pool","fillValue","imageWindowWidth","imageWindowHeight","numPixels","reject","apply","fill","getArrayForSample","Array","isArray","_readRaster","enableAlpha","pi","PhotometricInterpretation","readRasters","subOptions","ColorMap","ModelTiepoint","tiePoints","GDAL_NODATA","string","Number","substring","modelTransformation","ModelTransformation","referenceImage","modelPixelScale","ModelPixelScale","getResolution","refResX","refResY","refResZ","GTRasterTypeGeoKey","origin","getOrigin","resolution","x1","y1","x2","y2","DataView64","arrayBuffer","_dataView","left","combined","right","isSafeInteger","isNegative","carrying","DataSlice","sliceOffset","bigTiff","_sliceOffset","_littleEndian","_bigTiff","sliceTop","readUint32","readUint64","makeBufferSource","assign","target","chunk","iterable","results","lengthOfIterable","chunked","ci","endsWith","expectedEnding","substr","forEach","func","invert","oldObj","newObj","range","times","numTimes","toArray","toArrayRecursively","tagName2Code","geoKeyName2Code","name2code","typeName2byte","numBytesInIfd","_binBE","nextZero","o","oincr","readUshort","buff","readShort","ui8","i16","readInt","i32","readUint","ui32","readASCII","l","String","fromCharCode","join","readFloat","fl32","readDouble","fl64","writeUshort","writeUint","writeASCII","charCodeAt","writeDouble","_writeIFD","bin","_offset","ifd","filter","eoff","tag","typeName","typeNum","num","dlen","toff","encodeIfds","ifds","ifdo","noffs","encodeImage","metadata","prfx","img","convertToTids","error","metadataDefaults","writeGeotiff","isFlattened","numBands","flattenedValues","rowIndex","columnIndex","bandIndex","sort","GeoKeyDirectory","NumberOfKeys","geoKey","KeyID","Count","TIFFTagLocation","valueOffset","GeoAsciiParams","log","name","encodedMetadata","outputImage","DummyLogger","LOGGER","setLogger","logger","info","time","timeEnd","getFieldTypeLength","fieldType","BYTE","ASCII","SBYTE","UNDEFINED","SHORT","SSHORT","LONG","SLONG","FLOAT","IFD","RATIONAL","SRATIONAL","DOUBLE","LONG8","SLONG8","IFD8","parseGeoKeyDirectory","rawGeoKeyDirectory","geoKeyDirectory","location","getValues","dataSlice","readMethod","fieldTypeLength","readUint8","readInt8","readInt16","readInt32","readInt64","readFloat32","readFloat64","TextDecoder","ImageFileDirectory","nextIFDByteOffset","GeoTIFFImageIndexError","GeoTIFFBase","options","resX","resY","bbox","getImage","firstImage","usedImage","getImageCount","imageCount","imgBBox","getBoundingBox","oX","oY","rX","rY","usedBBox","allImages","image","subfileType","SubfileType","newSubfileType","NewSubfileType","imgResX","imgResY","imageResX","imageResY","GeoTIFF","firstIFDOffset","ifdRequests","ghostValues","fallbackSize","entrySize","offsetSize","getSlice","numDirEntries","byteSize","covers","entryCount","fieldTag","typeCount","fieldValues","actualOffset","readOffset","fieldDataSlice","indexOf","parseFileDirectoryAt","requestIFD","previousIfd","hasNext","heuristicAreaSize","detectionString","metadataSize","valuesString","split","fullString","close","BOM","headerData","TypeError","magicNumber","offsetByteSize","getUint64","MultiGeoTIFF","mainFile","overviewFiles","imageFiles","concat","fileDirectoriesPerFile","fileDirectoriesPerFileParsing","requests","file","parseFileDirectoriesPerFile","visited","relativeIndex","imageFile","ii","imageCounts","reduce","fromArrayBuffer","fromSource","writeArrayBuffer"],"mappings":"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","file":"geotiff.js","sourceRoot":"../src","sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","module.exports = require(\"regenerator-runtime\");\n","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;","function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;","function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest;","var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;","var _typeof = require(\"../helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;","function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nmodule.exports = _isNativeFunction;","function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nmodule.exports = _isNativeReflectConstruct;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nvar isNativeReflectConstruct = require(\"./isNativeReflectConstruct\");\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    module.exports = _construct = Reflect.construct;\n  } else {\n    module.exports = _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nmodule.exports = _construct;","var getPrototypeOf = require(\"./getPrototypeOf\");\n\nvar setPrototypeOf = require(\"./setPrototypeOf\");\n\nvar isNativeFunction = require(\"./isNativeFunction\");\n\nvar construct = require(\"./construct\");\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nmodule.exports = _wrapNativeSuper;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","export const fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n};\n\nexport const fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nexport const arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n];\n\nexport const fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nexport const fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nexport const ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\n\nexport const geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nexport const geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n","export function fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nexport function fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nexport function fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nexport function fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n","\nfunction decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nexport function applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n","import { applyPredictor } from '../predictor';\n\nexport default class BaseDecoder {\n  async decode(fileDirectory, buffer) {\n    const decoded = await this.decodeBlock(buffer);\n    const predictor = fileDirectory.Predictor || 1;\n    if (predictor !== 1) {\n      const isTiled = !fileDirectory.StripOffsets;\n      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\n      const tileHeight = isTiled ? fileDirectory.TileLength : (\n        fileDirectory.RowsPerStrip || fileDirectory.ImageLength\n      );\n      return applyPredictor(\n        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,\n        fileDirectory.PlanarConfiguration,\n      );\n    }\n    return decoded;\n  }\n}\n","import BaseDecoder from './basedecoder';\n\n\nexport default class RawDecoder extends BaseDecoder {\n  decodeBlock(buffer) {\n    return buffer;\n  }\n}\n","import BaseDecoder from './basedecoder';\n\n\nconst MIN_BITS = 9;\nconst CLEAR_CODE = 256; // clear code\nconst EOI_CODE = 257; // end of information\nconst MAX_BYTELENGTH = 12;\n\nfunction getByte(array, position, length) {\n  const d = position % 8;\n  const a = Math.floor(position / 8);\n  const de = 8 - d;\n  const ef = (position + length) - ((a + 1) * 8);\n  let fg = (8 * (a + 2)) - (position + length);\n  const dg = ((a + 2) * 8) - position;\n  fg = Math.max(0, fg);\n  if (a >= array.length) {\n    console.warn('ran off the end of the buffer before finding EOI_CODE (end on input code)');\n    return EOI_CODE;\n  }\n  let chunk1 = array[a] & ((2 ** (8 - d)) - 1);\n  chunk1 <<= (length - de);\n  let chunks = chunk1;\n  if (a + 1 < array.length) {\n    let chunk2 = array[a + 1] >>> fg;\n    chunk2 <<= Math.max(0, (length - dg));\n    chunks += chunk2;\n  }\n  if (ef > 8 && a + 2 < array.length) {\n    const hi = ((a + 3) * 8) - (position + length);\n    const chunk3 = array[a + 2] >>> hi;\n    chunks += chunk3;\n  }\n  return chunks;\n}\n\nfunction appendReversed(dest, source) {\n  for (let i = source.length - 1; i >= 0; i--) {\n    dest.push(source[i]);\n  }\n  return dest;\n}\n\nfunction decompress(input) {\n  const dictionaryIndex = new Uint16Array(4093);\n  const dictionaryChar = new Uint8Array(4093);\n  for (let i = 0; i <= 257; i++) {\n    dictionaryIndex[i] = 4096;\n    dictionaryChar[i] = i;\n  }\n  let dictionaryLength = 258;\n  let byteLength = MIN_BITS;\n  let position = 0;\n\n  function initDictionary() {\n    dictionaryLength = 258;\n    byteLength = MIN_BITS;\n  }\n  function getNext(array) {\n    const byte = getByte(array, position, byteLength);\n    position += byteLength;\n    return byte;\n  }\n  function addToDictionary(i, c) {\n    dictionaryChar[dictionaryLength] = c;\n    dictionaryIndex[dictionaryLength] = i;\n    dictionaryLength++;\n    return dictionaryLength - 1;\n  }\n  function getDictionaryReversed(n) {\n    const rev = [];\n    for (let i = n; i !== 4096; i = dictionaryIndex[i]) {\n      rev.push(dictionaryChar[i]);\n    }\n    return rev;\n  }\n\n  const result = [];\n  initDictionary();\n  const array = new Uint8Array(input);\n  let code = getNext(array);\n  let oldCode;\n  while (code !== EOI_CODE) {\n    if (code === CLEAR_CODE) {\n      initDictionary();\n      code = getNext(array);\n      while (code === CLEAR_CODE) {\n        code = getNext(array);\n      }\n\n      if (code === EOI_CODE) {\n        break;\n      } else if (code > CLEAR_CODE) {\n        throw new Error(`corrupted code at scanline ${code}`);\n      } else {\n        const val = getDictionaryReversed(code);\n        appendReversed(result, val);\n        oldCode = code;\n      }\n    } else if (code < dictionaryLength) {\n      const val = getDictionaryReversed(code);\n      appendReversed(result, val);\n      addToDictionary(oldCode, val[val.length - 1]);\n      oldCode = code;\n    } else {\n      const oldVal = getDictionaryReversed(oldCode);\n      if (!oldVal) {\n        throw new Error(`Bogus entry. Not in dictionary, ${oldCode} / ${dictionaryLength}, position: ${position}`);\n      }\n      appendReversed(result, oldVal);\n      result.push(oldVal[oldVal.length - 1]);\n      addToDictionary(oldCode, oldVal[oldVal.length - 1]);\n      oldCode = code;\n    }\n\n    if (dictionaryLength + 1 >= (2 ** byteLength)) {\n      if (byteLength === MAX_BYTELENGTH) {\n        oldCode = undefined;\n      } else {\n        byteLength++;\n      }\n    }\n    code = getNext(array);\n  }\n  return new Uint8Array(result);\n}\n\nexport default class LZWDecoder extends BaseDecoder {\n  decodeBlock(buffer) {\n    return decompress(buffer, false).buffer;\n  }\n}\n","import BaseDecoder from './basedecoder';\n\n/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n/*\n   Copyright 2011 notmasteryet\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n       http://www.apache.org/licenses/LICENSE-2.0\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\n// - The JPEG specification can be found in the ITU CCITT Recommendation T.81\n//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)\n// - The JFIF specification can be found in the JPEG File Interchange Format\n//   (www.w3.org/Graphics/JPEG/jfif3.pdf)\n// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters\n//   in PostScript Level 2, Technical Note #5116\n//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)\n\n\nconst dctZigZag = new Int32Array([\n  0,\n  1, 8,\n  16, 9, 2,\n  3, 10, 17, 24,\n  32, 25, 18, 11, 4,\n  5, 12, 19, 26, 33, 40,\n  48, 41, 34, 27, 20, 13, 6,\n  7, 14, 21, 28, 35, 42, 49, 56,\n  57, 50, 43, 36, 29, 22, 15,\n  23, 30, 37, 44, 51, 58,\n  59, 52, 45, 38, 31,\n  39, 46, 53, 60,\n  61, 54, 47,\n  55, 62,\n  63,\n]);\n\nconst dctCos1 = 4017; // cos(pi/16)\nconst dctSin1 = 799; // sin(pi/16)\nconst dctCos3 = 3406; // cos(3*pi/16)\nconst dctSin3 = 2276; // sin(3*pi/16)\nconst dctCos6 = 1567; // cos(6*pi/16)\nconst dctSin6 = 3784; // sin(6*pi/16)\nconst dctSqrt2 = 5793; // sqrt(2)\nconst dctSqrt1d2 = 2896;// sqrt(2) / 2\n\nfunction buildHuffmanTable(codeLengths, values) {\n  let k = 0;\n  const code = [];\n  let length = 16;\n  while (length > 0 && !codeLengths[length - 1]) {\n    --length;\n  }\n  code.push({ children: [], index: 0 });\n\n  let p = code[0];\n  let q;\n  for (let i = 0; i < length; i++) {\n    for (let j = 0; j < codeLengths[i]; j++) {\n      p = code.pop();\n      p.children[p.index] = values[k];\n      while (p.index > 0) {\n        p = code.pop();\n      }\n      p.index++;\n      code.push(p);\n      while (code.length <= i) {\n        code.push(q = { children: [], index: 0 });\n        p.children[p.index] = q.children;\n        p = q;\n      }\n      k++;\n    }\n    if (i + 1 < length) {\n      // p here points to last code\n      code.push(q = { children: [], index: 0 });\n      p.children[p.index] = q.children;\n      p = q;\n    }\n  }\n  return code[0].children;\n}\n\nfunction decodeScan(data, initialOffset,\n  frame, components, resetInterval,\n  spectralStart, spectralEnd,\n  successivePrev, successive) {\n  const { mcusPerLine, progressive } = frame;\n\n  const startOffset = initialOffset;\n  let offset = initialOffset;\n  let bitsData = 0;\n  let bitsCount = 0;\n  function readBit() {\n    if (bitsCount > 0) {\n      bitsCount--;\n      return (bitsData >> bitsCount) & 1;\n    }\n    bitsData = data[offset++];\n    if (bitsData === 0xFF) {\n      const nextByte = data[offset++];\n      if (nextByte) {\n        throw new Error(`unexpected marker: ${((bitsData << 8) | nextByte).toString(16)}`);\n      }\n      // unstuff 0\n    }\n    bitsCount = 7;\n    return bitsData >>> 7;\n  }\n  function decodeHuffman(tree) {\n    let node = tree;\n    let bit;\n    while ((bit = readBit()) !== null) { // eslint-disable-line no-cond-assign\n      node = node[bit];\n      if (typeof node === 'number') {\n        return node;\n      }\n      if (typeof node !== 'object') {\n        throw new Error('invalid huffman sequence');\n      }\n    }\n    return null;\n  }\n  function receive(initialLength) {\n    let length = initialLength;\n    let n = 0;\n    while (length > 0) {\n      const bit = readBit();\n      if (bit === null) {\n        return undefined;\n      }\n      n = (n << 1) | bit;\n      --length;\n    }\n    return n;\n  }\n  function receiveAndExtend(length) {\n    const n = receive(length);\n    if (n >= 1 << (length - 1)) {\n      return n;\n    }\n    return n + (-1 << length) + 1;\n  }\n  function decodeBaseline(component, zz) {\n    const t = decodeHuffman(component.huffmanTableDC);\n    const diff = t === 0 ? 0 : receiveAndExtend(t);\n    component.pred += diff;\n    zz[0] = component.pred;\n    let k = 1;\n    while (k < 64) {\n      const rs = decodeHuffman(component.huffmanTableAC);\n      const s = rs & 15;\n      const r = rs >> 4;\n      if (s === 0) {\n        if (r < 15) {\n          break;\n        }\n        k += 16;\n      } else {\n        k += r;\n        const z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s);\n        k++;\n      }\n    }\n  }\n  function decodeDCFirst(component, zz) {\n    const t = decodeHuffman(component.huffmanTableDC);\n    const diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);\n    component.pred += diff;\n    zz[0] = component.pred;\n  }\n  function decodeDCSuccessive(component, zz) {\n    zz[0] |= readBit() << successive;\n  }\n  let eobrun = 0;\n  function decodeACFirst(component, zz) {\n    if (eobrun > 0) {\n      eobrun--;\n      return;\n    }\n    let k = spectralStart;\n    const e = spectralEnd;\n    while (k <= e) {\n      const rs = decodeHuffman(component.huffmanTableAC);\n      const s = rs & 15;\n      const r = rs >> 4;\n      if (s === 0) {\n        if (r < 15) {\n          eobrun = receive(r) + (1 << r) - 1;\n          break;\n        }\n        k += 16;\n      } else {\n        k += r;\n        const z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s) * (1 << successive);\n        k++;\n      }\n    }\n  }\n  let successiveACState = 0;\n  let successiveACNextValue;\n  function decodeACSuccessive(component, zz) {\n    let k = spectralStart;\n    const e = spectralEnd;\n    let r = 0;\n    while (k <= e) {\n      const z = dctZigZag[k];\n      const direction = zz[z] < 0 ? -1 : 1;\n      switch (successiveACState) {\n        case 0: { // initial state\n          const rs = decodeHuffman(component.huffmanTableAC);\n          const s = rs & 15;\n          r = rs >> 4;\n          if (s === 0) {\n            if (r < 15) {\n              eobrun = receive(r) + (1 << r);\n              successiveACState = 4;\n            } else {\n              r = 16;\n              successiveACState = 1;\n            }\n          } else {\n            if (s !== 1) {\n              throw new Error('invalid ACn encoding');\n            }\n            successiveACNextValue = receiveAndExtend(s);\n            successiveACState = r ? 2 : 3;\n          }\n          continue; // eslint-disable-line no-continue\n        }\n        case 1: // skipping r zero items\n        case 2:\n          if (zz[z]) {\n            zz[z] += (readBit() << successive) * direction;\n          } else {\n            r--;\n            if (r === 0) {\n              successiveACState = successiveACState === 2 ? 3 : 0;\n            }\n          }\n          break;\n        case 3: // set value for a zero item\n          if (zz[z]) {\n            zz[z] += (readBit() << successive) * direction;\n          } else {\n            zz[z] = successiveACNextValue << successive;\n            successiveACState = 0;\n          }\n          break;\n        case 4: // eob\n          if (zz[z]) {\n            zz[z] += (readBit() << successive) * direction;\n          }\n          break;\n        default:\n          break;\n      }\n      k++;\n    }\n    if (successiveACState === 4) {\n      eobrun--;\n      if (eobrun === 0) {\n        successiveACState = 0;\n      }\n    }\n  }\n  function decodeMcu(component, decodeFunction, mcu, row, col) {\n    const mcuRow = (mcu / mcusPerLine) | 0;\n    const mcuCol = mcu % mcusPerLine;\n    const blockRow = (mcuRow * component.v) + row;\n    const blockCol = (mcuCol * component.h) + col;\n    decodeFunction(component, component.blocks[blockRow][blockCol]);\n  }\n  function decodeBlock(component, decodeFunction, mcu) {\n    const blockRow = (mcu / component.blocksPerLine) | 0;\n    const blockCol = mcu % component.blocksPerLine;\n    decodeFunction(component, component.blocks[blockRow][blockCol]);\n  }\n\n  const componentsLength = components.length;\n  let component;\n  let i;\n  let j;\n  let k;\n  let n;\n  let decodeFn;\n  if (progressive) {\n    if (spectralStart === 0) {\n      decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\n    } else {\n      decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n    }\n  } else {\n    decodeFn = decodeBaseline;\n  }\n\n  let mcu = 0;\n  let marker;\n  let mcuExpected;\n  if (componentsLength === 1) {\n    mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n  } else {\n    mcuExpected = mcusPerLine * frame.mcusPerColumn;\n  }\n\n  const usedResetInterval = resetInterval || mcuExpected;\n\n  while (mcu < mcuExpected) {\n    // reset interval stuff\n    for (i = 0; i < componentsLength; i++) {\n      components[i].pred = 0;\n    }\n    eobrun = 0;\n\n    if (componentsLength === 1) {\n      component = components[0];\n      for (n = 0; n < usedResetInterval; n++) {\n        decodeBlock(component, decodeFn, mcu);\n        mcu++;\n      }\n    } else {\n      for (n = 0; n < usedResetInterval; n++) {\n        for (i = 0; i < componentsLength; i++) {\n          component = components[i];\n          const { h, v } = component;\n          for (j = 0; j < v; j++) {\n            for (k = 0; k < h; k++) {\n              decodeMcu(component, decodeFn, mcu, j, k);\n            }\n          }\n        }\n        mcu++;\n\n        // If we've reached our expected MCU's, stop decoding\n        if (mcu === mcuExpected) {\n          break;\n        }\n      }\n    }\n\n    // find marker\n    bitsCount = 0;\n    marker = (data[offset] << 8) | data[offset + 1];\n    if (marker < 0xFF00) {\n      throw new Error('marker was not found');\n    }\n\n    if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx\n      offset += 2;\n    } else {\n      break;\n    }\n  }\n\n  return offset - startOffset;\n}\n\nfunction buildComponentData(frame, component) {\n  const lines = [];\n  const { blocksPerLine, blocksPerColumn } = component;\n  const samplesPerLine = blocksPerLine << 3;\n  const R = new Int32Array(64);\n  const r = new Uint8Array(64);\n\n  // A port of poppler's IDCT method which in turn is taken from:\n  //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,\n  //   \"Practical Fast 1-D DCT Algorithms with 11 Multiplications\",\n  //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,\n  //   988-991.\n  function quantizeAndInverse(zz, dataOut, dataIn) {\n    const qt = component.quantizationTable;\n    let v0;\n    let v1;\n    let v2;\n    let v3;\n    let v4;\n    let v5;\n    let v6;\n    let v7;\n    let t;\n    const p = dataIn;\n    let i;\n\n    // dequant\n    for (i = 0; i < 64; i++) {\n      p[i] = zz[i] * qt[i];\n    }\n\n    // inverse DCT on rows\n    for (i = 0; i < 8; ++i) {\n      const row = 8 * i;\n\n      // check for all-zero AC coefficients\n      if (p[1 + row] === 0 && p[2 + row] === 0 && p[3 + row] === 0\n        && p[4 + row] === 0 && p[5 + row] === 0 && p[6 + row] === 0\n        && p[7 + row] === 0) {\n        t = ((dctSqrt2 * p[0 + row]) + 512) >> 10;\n        p[0 + row] = t;\n        p[1 + row] = t;\n        p[2 + row] = t;\n        p[3 + row] = t;\n        p[4 + row] = t;\n        p[5 + row] = t;\n        p[6 + row] = t;\n        p[7 + row] = t;\n        continue; // eslint-disable-line no-continue\n      }\n\n      // stage 4\n      v0 = ((dctSqrt2 * p[0 + row]) + 128) >> 8;\n      v1 = ((dctSqrt2 * p[4 + row]) + 128) >> 8;\n      v2 = p[2 + row];\n      v3 = p[6 + row];\n      v4 = ((dctSqrt1d2 * (p[1 + row] - p[7 + row])) + 128) >> 8;\n      v7 = ((dctSqrt1d2 * (p[1 + row] + p[7 + row])) + 128) >> 8;\n      v5 = p[3 + row] << 4;\n      v6 = p[5 + row] << 4;\n\n      // stage 3\n      t = (v0 - v1 + 1) >> 1;\n      v0 = (v0 + v1 + 1) >> 1;\n      v1 = t;\n      t = ((v2 * dctSin6) + (v3 * dctCos6) + 128) >> 8;\n      v2 = ((v2 * dctCos6) - (v3 * dctSin6) + 128) >> 8;\n      v3 = t;\n      t = (v4 - v6 + 1) >> 1;\n      v4 = (v4 + v6 + 1) >> 1;\n      v6 = t;\n      t = (v7 + v5 + 1) >> 1;\n      v5 = (v7 - v5 + 1) >> 1;\n      v7 = t;\n\n      // stage 2\n      t = (v0 - v3 + 1) >> 1;\n      v0 = (v0 + v3 + 1) >> 1;\n      v3 = t;\n      t = (v1 - v2 + 1) >> 1;\n      v1 = (v1 + v2 + 1) >> 1;\n      v2 = t;\n      t = ((v4 * dctSin3) + (v7 * dctCos3) + 2048) >> 12;\n      v4 = ((v4 * dctCos3) - (v7 * dctSin3) + 2048) >> 12;\n      v7 = t;\n      t = ((v5 * dctSin1) + (v6 * dctCos1) + 2048) >> 12;\n      v5 = ((v5 * dctCos1) - (v6 * dctSin1) + 2048) >> 12;\n      v6 = t;\n\n      // stage 1\n      p[0 + row] = v0 + v7;\n      p[7 + row] = v0 - v7;\n      p[1 + row] = v1 + v6;\n      p[6 + row] = v1 - v6;\n      p[2 + row] = v2 + v5;\n      p[5 + row] = v2 - v5;\n      p[3 + row] = v3 + v4;\n      p[4 + row] = v3 - v4;\n    }\n\n    // inverse DCT on columns\n    for (i = 0; i < 8; ++i) {\n      const col = i;\n\n      // check for all-zero AC coefficients\n      if (p[(1 * 8) + col] === 0 && p[(2 * 8) + col] === 0 && p[(3 * 8) + col] === 0\n        && p[(4 * 8) + col] === 0 && p[(5 * 8) + col] === 0 && p[(6 * 8) + col] === 0\n        && p[(7 * 8) + col] === 0) {\n        t = ((dctSqrt2 * dataIn[i + 0]) + 8192) >> 14;\n        p[(0 * 8) + col] = t;\n        p[(1 * 8) + col] = t;\n        p[(2 * 8) + col] = t;\n        p[(3 * 8) + col] = t;\n        p[(4 * 8) + col] = t;\n        p[(5 * 8) + col] = t;\n        p[(6 * 8) + col] = t;\n        p[(7 * 8) + col] = t;\n        continue; // eslint-disable-line no-continue\n      }\n\n      // stage 4\n      v0 = ((dctSqrt2 * p[(0 * 8) + col]) + 2048) >> 12;\n      v1 = ((dctSqrt2 * p[(4 * 8) + col]) + 2048) >> 12;\n      v2 = p[(2 * 8) + col];\n      v3 = p[(6 * 8) + col];\n      v4 = ((dctSqrt1d2 * (p[(1 * 8) + col] - p[(7 * 8) + col])) + 2048) >> 12;\n      v7 = ((dctSqrt1d2 * (p[(1 * 8) + col] + p[(7 * 8) + col])) + 2048) >> 12;\n      v5 = p[(3 * 8) + col];\n      v6 = p[(5 * 8) + col];\n\n      // stage 3\n      t = (v0 - v1 + 1) >> 1;\n      v0 = (v0 + v1 + 1) >> 1;\n      v1 = t;\n      t = ((v2 * dctSin6) + (v3 * dctCos6) + 2048) >> 12;\n      v2 = ((v2 * dctCos6) - (v3 * dctSin6) + 2048) >> 12;\n      v3 = t;\n      t = (v4 - v6 + 1) >> 1;\n      v4 = (v4 + v6 + 1) >> 1;\n      v6 = t;\n      t = (v7 + v5 + 1) >> 1;\n      v5 = (v7 - v5 + 1) >> 1;\n      v7 = t;\n\n      // stage 2\n      t = (v0 - v3 + 1) >> 1;\n      v0 = (v0 + v3 + 1) >> 1;\n      v3 = t;\n      t = (v1 - v2 + 1) >> 1;\n      v1 = (v1 + v2 + 1) >> 1;\n      v2 = t;\n      t = ((v4 * dctSin3) + (v7 * dctCos3) + 2048) >> 12;\n      v4 = ((v4 * dctCos3) - (v7 * dctSin3) + 2048) >> 12;\n      v7 = t;\n      t = ((v5 * dctSin1) + (v6 * dctCos1) + 2048) >> 12;\n      v5 = ((v5 * dctCos1) - (v6 * dctSin1) + 2048) >> 12;\n      v6 = t;\n\n      // stage 1\n      p[(0 * 8) + col] = v0 + v7;\n      p[(7 * 8) + col] = v0 - v7;\n      p[(1 * 8) + col] = v1 + v6;\n      p[(6 * 8) + col] = v1 - v6;\n      p[(2 * 8) + col] = v2 + v5;\n      p[(5 * 8) + col] = v2 - v5;\n      p[(3 * 8) + col] = v3 + v4;\n      p[(4 * 8) + col] = v3 - v4;\n    }\n\n    // convert to 8-bit integers\n    for (i = 0; i < 64; ++i) {\n      const sample = 128 + ((p[i] + 8) >> 4);\n      if (sample < 0) {\n        dataOut[i] = 0;\n      } else if (sample > 0XFF) {\n        dataOut[i] = 0xFF;\n      } else {\n        dataOut[i] = sample;\n      }\n    }\n  }\n\n  for (let blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n    const scanLine = blockRow << 3;\n    for (let i = 0; i < 8; i++) {\n      lines.push(new Uint8Array(samplesPerLine));\n    }\n    for (let blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n      quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);\n\n      let offset = 0;\n      const sample = blockCol << 3;\n      for (let j = 0; j < 8; j++) {\n        const line = lines[scanLine + j];\n        for (let i = 0; i < 8; i++) {\n          line[sample + i] = r[offset++];\n        }\n      }\n    }\n  }\n  return lines;\n}\n\nclass JpegStreamReader {\n  constructor() {\n    this.jfif = null;\n    this.adobe = null;\n\n    this.quantizationTables = [];\n    this.huffmanTablesAC = [];\n    this.huffmanTablesDC = [];\n    this.resetFrames();\n  }\n\n  resetFrames() {\n    this.frames = [];\n  }\n\n  parse(data) {\n    let offset = 0;\n    // const { length } = data;\n    function readUint16() {\n      const value = (data[offset] << 8) | data[offset + 1];\n      offset += 2;\n      return value;\n    }\n    function readDataBlock() {\n      const length = readUint16();\n      const array = data.subarray(offset, offset + length - 2);\n      offset += array.length;\n      return array;\n    }\n    function prepareComponents(frame) {\n      let maxH = 0;\n      let maxV = 0;\n      let component;\n      let componentId;\n      for (componentId in frame.components) {\n        if (frame.components.hasOwnProperty(componentId)) {\n          component = frame.components[componentId];\n          if (maxH < component.h) {\n            maxH = component.h;\n          }\n          if (maxV < component.v) {\n            maxV = component.v;\n          }\n        }\n      }\n      const mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);\n      const mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);\n      for (componentId in frame.components) {\n        if (frame.components.hasOwnProperty(componentId)) {\n          component = frame.components[componentId];\n          const blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);\n          const blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / maxV);\n          const blocksPerLineForMcu = mcusPerLine * component.h;\n          const blocksPerColumnForMcu = mcusPerColumn * component.v;\n          const blocks = [];\n          for (let i = 0; i < blocksPerColumnForMcu; i++) {\n            const row = [];\n            for (let j = 0; j < blocksPerLineForMcu; j++) {\n              row.push(new Int32Array(64));\n            }\n            blocks.push(row);\n          }\n          component.blocksPerLine = blocksPerLine;\n          component.blocksPerColumn = blocksPerColumn;\n          component.blocks = blocks;\n        }\n      }\n      frame.maxH = maxH;\n      frame.maxV = maxV;\n      frame.mcusPerLine = mcusPerLine;\n      frame.mcusPerColumn = mcusPerColumn;\n    }\n\n    let fileMarker = readUint16();\n    if (fileMarker !== 0xFFD8) { // SOI (Start of Image)\n      throw new Error('SOI not found');\n    }\n\n    fileMarker = readUint16();\n    while (fileMarker !== 0xFFD9) { // EOI (End of image)\n      switch (fileMarker) {\n        case 0xFF00: break;\n        case 0xFFE0: // APP0 (Application Specific)\n        case 0xFFE1: // APP1\n        case 0xFFE2: // APP2\n        case 0xFFE3: // APP3\n        case 0xFFE4: // APP4\n        case 0xFFE5: // APP5\n        case 0xFFE6: // APP6\n        case 0xFFE7: // APP7\n        case 0xFFE8: // APP8\n        case 0xFFE9: // APP9\n        case 0xFFEA: // APP10\n        case 0xFFEB: // APP11\n        case 0xFFEC: // APP12\n        case 0xFFED: // APP13\n        case 0xFFEE: // APP14\n        case 0xFFEF: // APP15\n        case 0xFFFE: { // COM (Comment)\n          const appData = readDataBlock();\n\n          if (fileMarker === 0xFFE0) {\n            if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49\n              && appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\\x00'\n              this.jfif = {\n                version: { major: appData[5], minor: appData[6] },\n                densityUnits: appData[7],\n                xDensity: (appData[8] << 8) | appData[9],\n                yDensity: (appData[10] << 8) | appData[11],\n                thumbWidth: appData[12],\n                thumbHeight: appData[13],\n                thumbData: appData.subarray(14, 14 + (3 * appData[12] * appData[13])),\n              };\n            }\n          }\n          // TODO APP1 - Exif\n          if (fileMarker === 0xFFEE) {\n            if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F\n              && appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\\x00'\n              this.adobe = {\n                version: appData[6],\n                flags0: (appData[7] << 8) | appData[8],\n                flags1: (appData[9] << 8) | appData[10],\n                transformCode: appData[11],\n              };\n            }\n          }\n          break;\n        }\n\n        case 0xFFDB: { // DQT (Define Quantization Tables)\n          const quantizationTablesLength = readUint16();\n          const quantizationTablesEnd = quantizationTablesLength + offset - 2;\n          while (offset < quantizationTablesEnd) {\n            const quantizationTableSpec = data[offset++];\n            const tableData = new Int32Array(64);\n            if ((quantizationTableSpec >> 4) === 0) { // 8 bit values\n              for (let j = 0; j < 64; j++) {\n                const z = dctZigZag[j];\n                tableData[z] = data[offset++];\n              }\n            } else if ((quantizationTableSpec >> 4) === 1) { // 16 bit\n              for (let j = 0; j < 64; j++) {\n                const z = dctZigZag[j];\n                tableData[z] = readUint16();\n              }\n            } else {\n              throw new Error('DQT: invalid table spec');\n            }\n            this.quantizationTables[quantizationTableSpec & 15] = tableData;\n          }\n          break;\n        }\n\n        case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)\n        case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)\n        case 0xFFC2: { // SOF2 (Start of Frame, Progressive DCT)\n          readUint16(); // skip data length\n          const frame = {\n            extended: (fileMarker === 0xFFC1),\n            progressive: (fileMarker === 0xFFC2),\n            precision: data[offset++],\n            scanLines: readUint16(),\n            samplesPerLine: readUint16(),\n            components: {},\n            componentsOrder: [],\n          };\n\n          const componentsCount = data[offset++];\n          let componentId;\n          // let maxH = 0;\n          // let maxV = 0;\n          for (let i = 0; i < componentsCount; i++) {\n            componentId = data[offset];\n            const h = data[offset + 1] >> 4;\n            const v = data[offset + 1] & 15;\n            const qId = data[offset + 2];\n            frame.componentsOrder.push(componentId);\n            frame.components[componentId] = {\n              h,\n              v,\n              quantizationIdx: qId,\n            };\n            offset += 3;\n          }\n          prepareComponents(frame);\n          this.frames.push(frame);\n          break;\n        }\n\n        case 0xFFC4: { // DHT (Define Huffman Tables)\n          const huffmanLength = readUint16();\n          for (let i = 2; i < huffmanLength;) {\n            const huffmanTableSpec = data[offset++];\n            const codeLengths = new Uint8Array(16);\n            let codeLengthSum = 0;\n            for (let j = 0; j < 16; j++, offset++) {\n              codeLengths[j] = data[offset];\n              codeLengthSum += codeLengths[j];\n            }\n            const huffmanValues = new Uint8Array(codeLengthSum);\n            for (let j = 0; j < codeLengthSum; j++, offset++) {\n              huffmanValues[j] = data[offset];\n            }\n            i += 17 + codeLengthSum;\n\n            if ((huffmanTableSpec >> 4) === 0) {\n              this.huffmanTablesDC[huffmanTableSpec & 15] = buildHuffmanTable(\n                codeLengths, huffmanValues,\n              );\n            } else {\n              this.huffmanTablesAC[huffmanTableSpec & 15] = buildHuffmanTable(\n                codeLengths, huffmanValues,\n              );\n            }\n          }\n          break;\n        }\n\n        case 0xFFDD: // DRI (Define Restart Interval)\n          readUint16(); // skip data length\n          this.resetInterval = readUint16();\n          break;\n\n        case 0xFFDA: { // SOS (Start of Scan)\n          readUint16(); // skip length\n          const selectorsCount = data[offset++];\n          const components = [];\n          const frame = this.frames[0];\n          for (let i = 0; i < selectorsCount; i++) {\n            const component = frame.components[data[offset++]];\n            const tableSpec = data[offset++];\n            component.huffmanTableDC = this.huffmanTablesDC[tableSpec >> 4];\n            component.huffmanTableAC = this.huffmanTablesAC[tableSpec & 15];\n            components.push(component);\n          }\n          const spectralStart = data[offset++];\n          const spectralEnd = data[offset++];\n          const successiveApproximation = data[offset++];\n          const processed = decodeScan(data, offset,\n            frame, components, this.resetInterval,\n            spectralStart, spectralEnd,\n            successiveApproximation >> 4, successiveApproximation & 15);\n          offset += processed;\n          break;\n        }\n\n        case 0xFFFF: // Fill bytes\n          if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.\n            offset--;\n          }\n          break;\n\n        default:\n          if (data[offset - 3] === 0xFF\n            && data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {\n            // could be incorrect encoding -- last 0xFF byte of the previous\n            // block was eaten by the encoder\n            offset -= 3;\n            break;\n          }\n          throw new Error(`unknown JPEG marker ${fileMarker.toString(16)}`);\n      }\n      fileMarker = readUint16();\n    }\n  }\n\n  getResult() {\n    const { frames } = this;\n    if (this.frames.length === 0) {\n      throw new Error('no frames were decoded');\n    } else if (this.frames.length > 1) {\n      console.warn('more than one frame is not supported');\n    }\n\n    // set each frame's components quantization table\n    for (let i = 0; i < this.frames.length; i++) {\n      const cp = this.frames[i].components;\n      for (const j of Object.keys(cp)) {\n        cp[j].quantizationTable = this.quantizationTables[cp[j].quantizationIdx];\n        delete cp[j].quantizationIdx;\n      }\n    }\n\n    const frame = frames[0];\n    const { components, componentsOrder } = frame;\n    const outComponents = [];\n    const width = frame.samplesPerLine;\n    const height = frame.scanLines;\n\n    for (let i = 0; i < componentsOrder.length; i++) {\n      const component = components[componentsOrder[i]];\n      outComponents.push({\n        lines: buildComponentData(frame, component),\n        scaleX: component.h / frame.maxH,\n        scaleY: component.v / frame.maxV,\n      });\n    }\n\n    const out = new Uint8Array(width * height * outComponents.length);\n    let oi = 0;\n    for (let y = 0; y < height; ++y) {\n      for (let x = 0; x < width; ++x) {\n        for (let i = 0; i < outComponents.length; ++i) {\n          const component = outComponents[i];\n          out[oi] = component.lines[0 | y * component.scaleY][0 | x * component.scaleX];\n          ++oi;\n        }\n      }\n    }\n    return out;\n  }\n}\n\nexport default class JpegDecoder extends BaseDecoder {\n  constructor(fileDirectory) {\n    super();\n    this.reader = new JpegStreamReader();\n    if (fileDirectory.JPEGTables) {\n      this.reader.parse(fileDirectory.JPEGTables);\n    }\n  }\n\n  decodeBlock(buffer) {\n    this.reader.resetFrames();\n    this.reader.parse(new Uint8Array(buffer));\n    return this.reader.getResult().buffer;\n  }\n}\n","import BaseDecoder from './basedecoder';\n\n\nexport default class PackbitsDecoder extends BaseDecoder {\n  decodeBlock(buffer) {\n    const dataView = new DataView(buffer);\n    const out = [];\n\n    for (let i = 0; i < buffer.byteLength; ++i) {\n      let header = dataView.getInt8(i);\n      if (header < 0) {\n        const next = dataView.getUint8(i + 1);\n        header = -header;\n        for (let j = 0; j <= header; ++j) {\n          out.push(next);\n        }\n        i += 1;\n      } else {\n        for (let j = 0; j <= header; ++j) {\n          out.push(dataView.getUint8(i + j + 1));\n        }\n        i += header + 1;\n      }\n    }\n    return new Uint8Array(out).buffer;\n  }\n}\n","import RawDecoder from \"./raw\";\nimport LZWDecoder from \"./lzw\";\nimport JpegDecoder from \"./jpeg\";\nimport PackbitsDecoder from \"./packbits\";\n\nexport function getDecoder(fileDirectory) {\n  switch (fileDirectory.Compression) {\n    case undefined:\n    case 1: // no compression\n      return new RawDecoder();\n    case 5: // LZW\n      return new LZWDecoder();\n    case 6: // JPEG\n      throw new Error(\"old style JPEG compression is not supported.\");\n    case 7: // JPEG\n      return new JpegDecoder(fileDirectory);\n    case 8: // Deflate as recognized by Adobe\n    case 32773: // packbits\n      return new PackbitsDecoder();\n    default:\n      throw new Error(\n        `Unknown compression method identifier: ${fileDirectory.Compression}`\n      );\n  }\n}\n","/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n","/* eslint max-len: [\"error\", { \"code\": 120 }] */\n\nimport { photometricInterpretations, ExtraSamplesValues } from \"./globals\";\nimport {\n  fromWhiteIsZero,\n  fromBlackIsZero,\n  fromPalette,\n  fromCMYK,\n  fromYCbCr,\n  fromCIELab,\n} from \"./rgb\";\nimport { getDecoder } from \"./compression\";\nimport { resample, resampleInterleaved } from \"./resample\";\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      switch (bitsPerSample) {\n        case 8:\n          return new Uint8Array(size);\n        case 16:\n          return new Uint16Array(size);\n        case 32:\n          return new Uint32Array(size);\n        default:\n          break;\n      }\n      break;\n    case 2: // twos complement signed integer data\n      switch (bitsPerSample) {\n        case 8:\n          return new Int8Array(size);\n        case 16:\n          return new Int16Array(size);\n        case 32:\n          return new Int32Array(size);\n        default:\n          break;\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error(\"Unsupported data format/bitsPerSample\");\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {Source} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration =\n      typeof planarConfiguration === \"undefined\" ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error(\"Invalid planar configuration.\");\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return this.fileDirectory.SamplesPerPixel;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== \"undefined\") {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bitsPerSample = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      const bits = this.fileDirectory.BitsPerSample[i];\n      if (bits % 8 !== 0) {\n        throw new Error(`Sample bit-width of ${bits} is not supported.`);\n      } else if (bits !== this.fileDirectory.BitsPerSample[0]) {\n        throw new Error(\n          \"Differing size of samples in a pixel are not supported.\"\n        );\n      }\n      bitsPerSample += bits;\n    }\n    return bitsPerSample / 8;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    const bits = this.fileDirectory.BitsPerSample[i];\n    if (bits % 8 !== 0) {\n      throw new Error(`Sample bit-width of ${bits} is not supported.`);\n    }\n    return bits / 8;\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex]\n      : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        switch (bitsPerSample) {\n          case 8:\n            return DataView.prototype.getUint8;\n          case 16:\n            return DataView.prototype.getUint16;\n          case 32:\n            return DataView.prototype.getUint32;\n          default:\n            break;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        switch (bitsPerSample) {\n          case 8:\n            return DataView.prototype.getInt8;\n          case 16:\n            return DataView.prototype.getInt16;\n          case 32:\n            return DataView.prototype.getInt32;\n          default:\n            break;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error(\"Unsupported data format/bitsPerSample\");\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex]\n      : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = y * numTilesPerRow + x;\n    } else if (this.planarConfiguration === 2) {\n      index = sample * numTilesPerRow * numTilesPerCol + y * numTilesPerRow + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = await this.source.fetch(offset, byteCount);\n\n    // either use the provided pool or decoder to decode the data\n    let request;\n    if (tiles === null) {\n      request = poolOrDecoder.decode(this.fileDirectory, slice);\n    } else if (!tiles[index]) {\n      request = poolOrDecoder.decode(this.fileDirectory, slice);\n      tiles[index] = request;\n    }\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray[]|TypedArray} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {Pool} pool The decoder pool\n   * @returns {Promise<TypedArray[]>|Promise<TypedArray>}\n   */\n  async _readRaster(\n    imageWindow,\n    samples,\n    valueArrays,\n    interleave,\n    poolOrDecoder,\n    width,\n    height,\n    resampleMethod\n  ) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(this.getWidth() / this.getTileWidth())\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(this.getHeight() / this.getTileHeight())\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(\n          sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8\n        );\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sample);\n          }\n          const promise = this.getTileOrStrip(\n            xTile,\n            yTile,\n            sample,\n            poolOrDecoder\n          );\n          promises.push(promise);\n          promise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = (tile.y + 1) * tileHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(\n              tileHeight,\n              tileHeight - (lastLine - imageWindow[3])\n            );\n            const xmax = Math.min(\n              tileWidth,\n              tileWidth - (lastCol - imageWindow[2])\n            );\n\n            for (\n              let y = Math.max(0, imageWindow[1] - firstLine);\n              y < ymax;\n              ++y\n            ) {\n              for (\n                let x = Math.max(0, imageWindow[0] - firstCol);\n                x < xmax;\n                ++x\n              ) {\n                const pixelOffset = (y * tileWidth + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView,\n                  pixelOffset + srcSampleOffsets[si],\n                  littleEndian\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate =\n                    (y + firstLine - imageWindow[1]) *\n                      windowWidth *\n                      samples.length +\n                    (x + firstCol - imageWindow[0]) * samples.length +\n                    si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate =\n                    (y + firstLine - imageWindow[1]) * windowWidth +\n                    x +\n                    firstCol -\n                    imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if (\n      (width && imageWindow[2] - imageWindow[0] !== width) ||\n      (height && imageWindow[3] - imageWindow[1] !== height)\n    ) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width,\n          height,\n          samples.length,\n          resampleMethod\n        );\n      } else {\n        resampled = resample(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width,\n          height,\n          resampleMethod\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {Object} [options={}] optional parameters\n   * @param {Array} [options.window=whole image] the subset to read data from.\n   * @param {Array} [options.samples=all samples] the selection of samples to read from.\n   * @param {Boolean} [options.interleave=false] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {Number} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is\n   *                                 not the same as the images, resampling will be\n   *                                 performed.\n   * @param {number} [options.height] The desired height of the output. When the width\n   *                                  is not the same as the images, resampling will\n   *                                  be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {number|number[]} [options.fillValue] The value to use for parts of the image\n   *                                              outside of the images extent. When\n   *                                              multiple samples are requested, an\n   *                                              array of fill values can be passed.\n   * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd,\n    samples = [],\n    interleave,\n    pool = null,\n    width,\n    height,\n    resampleMethod,\n    fillValue,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error(\"Invalid subsets\");\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < this.fileDirectory.SamplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= this.fileDirectory.SamplesPerPixel) {\n          return Promise.reject(\n            new RangeError(`Invalid sample index '${samples[i]}'.`)\n          );\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat)\n        : 1;\n      const bitsPerSample = Math.max.apply(\n        null,\n        this.fileDirectory.BitsPerSample\n      );\n      valueArrays = arrayForType(\n        format,\n        bitsPerSample,\n        numPixels * samples.length\n      );\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || getDecoder(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow,\n      samples,\n      valueArrays,\n      interleave,\n      poolOrDecoder,\n      width,\n      height,\n      resampleMethod\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * greayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array} [options.window=whole image] the subset to read data from.\n   * @param {Number} [pool=null] The optional decoder pool to use.\n   * @param {number} [width] The desired width of the output. When the width is no the\n   *                         same as the images, resampling will be performed.\n   * @param {number} [height] The desired height of the output. When the width is no the\n   *                          same as the images, resampling will be performed.\n   * @param {string} [resampleMethod='nearest'] The desired resampling method.\n   * @param {bool} [enableAlpha=false] Enable reading alpha channel if present.\n   * @returns {Promise.<TypedArray|TypedArray[]>} the RGB array as a Promise\n   */\n  async readRGB({\n    window,\n    pool = null,\n    width,\n    height,\n    resampleMethod,\n    enableAlpha = false,\n  } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error(\"Invalid subsets\");\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if (\n        !(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified) &&\n        enableAlpha\n      ) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave: true,\n        samples: s,\n        pool,\n        width,\n        height,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error(\"Invalid or unsupported photometric interpretation.\");\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error(\"Unsupported photometric interpretation.\");\n    }\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {Number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    return null;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {Number} or null\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [tiePoints[3], tiePoints[4], tiePoints[5]];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error(\"The image does not have an affine transformation.\");\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [modelPixelScale[0], -modelPixelScale[1], modelPixelScale[2]];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[0],\n        modelTransformation[5],\n        modelTransformation[10],\n      ];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        (refResX * referenceImage.getWidth()) / this.getWidth(),\n        (refResY * referenceImage.getHeight()) / this.getHeight(),\n        (refResZ * referenceImage.getWidth()) / this.getWidth(),\n      ];\n    }\n\n    throw new Error(\"The image does not have an affine transformation.\");\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @returns {Array} The bounding box\n   */\n  getBoundingBox() {\n    const origin = this.getOrigin();\n    const resolution = this.getResolution();\n\n    const x1 = origin[0];\n    const y1 = origin[1];\n\n    const x2 = x1 + resolution[0] * this.getWidth();\n    const y2 = y1 + resolution[1] * this.getHeight();\n\n    return [\n      Math.min(x1, x2),\n      Math.min(y1, y2),\n      Math.max(x1, x2),\n      Math.max(y1, y2),\n    ];\n  }\n}\n\nexport default GeoTIFFImage;\n","export default class DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + 2 ** 32 * right;\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`\n        );\n      }\n      return combined;\n    }\n    combined = 2 ** 32 * left + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative =\n      (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * 256 ** i;\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n","export default class DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + 2 ** 32 * right;\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`,\n        );\n      }\n      return combined;\n    }\n    combined = 2 ** 32 * left + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`,\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative =\n      (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80) >\n      0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i)\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * 256 ** i;\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n","export function makeBufferSource(arrayBuffer) {\n  return {\n    async fetch(offset, length) {\n      return arrayBuffer.slice(offset, offset + length);\n    },\n  };\n}\n","export function assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nexport function chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nexport function endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nexport function forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nexport function invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nexport function range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nexport function times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nexport function toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nexport function toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n","/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\nimport { fieldTagNames, fieldTagTypes, fieldTypeNames, geoKeyNames } from './globals';\nimport { assign, endsWith, forEach, invert, times } from './utils';\n\nconst tagName2Code = invert(fieldTagNames);\nconst geoKeyName2Code = invert(geoKeyNames);\nconst name2code = {};\nassign(name2code, tagName2Code);\nassign(name2code, geoKeyName2Code);\nconst typeName2byte = invert(fieldTypeNames);\n\n// config variables\nconst numBytesInIfd = 1000;\n\nconst _binBE = {\n  nextZero: (data, o) => {\n    let oincr = o;\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n    return oincr;\n  },\n  readUshort: (buff, p) => {\n    return (buff[p] << 8) | buff[p + 1];\n  },\n  readShort: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: (buff, p, l) => {\n    return l.map((i) => String.fromCharCode(buff[p + i])).join('');\n  },\n  readFloat: (buff, p) => {\n    const a = _binBE.ui8;\n    times(4, (i) => {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: (buff, p) => {\n    const a = _binBE.ui8;\n    times(8, (i) => {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: (buff, p, n) => {\n    buff[p] = (n >> 8) & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: (buff, p, n) => {\n    buff[p] = (n >> 24) & 255;\n    buff[p + 1] = (n >> 16) & 255;\n    buff[p + 2] = (n >> 8) & 255;\n    buff[p + 3] = (n >> 0) & 255;\n  },\n  writeASCII: (buff, p, s) => {\n    times(s.length, (i) => {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8),\n};\n\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n\n_binBE.writeDouble = (buff, p, n) => {\n  _binBE.fl64[0] = n;\n  times(8, (i) => {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\n\n\nconst _writeIFD = (bin, data, _offset, ifd) => {\n  let offset = _offset;\n\n  const keys = Object.keys(ifd).filter((key) => {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n\n  let eoff = offset + (12 * keys.length) + 4;\n\n  for (const key of keys) {\n    let tag = null;\n    if (typeof key === 'number') {\n      tag = key;\n    } else if (typeof key === 'string') {\n      tag = parseInt(key, 10);\n    }\n\n    const typeName = fieldTagTypes[tag];\n    const typeNum = typeName2byte[typeName];\n\n    if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n      throw new Error(`unknown type of tag: ${tag}`);\n    }\n\n    let val = ifd[key];\n\n    if (typeof val === 'undefined') {\n      throw new Error(`failed to get value for key ${key}`);\n    }\n\n    // ASCIIZ format with trailing 0 character\n    // http://www.fileformat.info/format/tiff/corion.htm\n    // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n    if (typeName === 'ASCII' && typeof val === 'string' && endsWith(val, '\\u0000') === false) {\n      val += '\\u0000';\n    }\n\n    const num = val.length;\n\n    bin.writeUshort(data, offset, tag);\n    offset += 2;\n\n    bin.writeUshort(data, offset, typeNum);\n    offset += 2;\n\n    bin.writeUint(data, offset, num);\n    offset += 4;\n\n    let dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n    let toff = offset;\n\n    if (dlen > 4) {\n      bin.writeUint(data, offset, eoff);\n      toff = eoff;\n    }\n\n    if (typeName === 'ASCII') {\n      bin.writeASCII(data, toff, val);\n    } else if (typeName === 'SHORT') {\n      times(num, (i) => {\n        bin.writeUshort(data, toff + (2 * i), val[i]);\n      });\n    } else if (typeName === 'LONG') {\n      times(num, (i) => {\n        bin.writeUint(data, toff + (4 * i), val[i]);\n      });\n    } else if (typeName === 'RATIONAL') {\n      times(num, (i) => {\n        bin.writeUint(data, toff + (8 * i), Math.round(val[i] * 10000));\n        bin.writeUint(data, toff + (8 * i) + 4, 10000);\n      });\n    } else if (typeName === 'DOUBLE') {\n      times(num, (i) => {\n        bin.writeDouble(data, toff + (8 * i), val[i]);\n      });\n    }\n\n    if (dlen > 4) {\n      dlen += (dlen & 1);\n      eoff += dlen;\n    }\n\n    offset += 4;\n  }\n\n  return [offset, eoff];\n};\n\nconst encodeIfds = (ifds) => {\n  const data = new Uint8Array(numBytesInIfd);\n  let offset = 4;\n  const bin = _binBE;\n\n  // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[0] = 77;\n  data[1] = 77;\n\n  // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[3] = 42;\n\n  let ifdo = 8;\n\n  bin.writeUint(data, offset, ifdo);\n\n  offset += 4;\n\n  ifds.forEach((ifd, i) => {\n    const noffs = _writeIFD(bin, data, ifdo, ifd);\n    ifdo = noffs[1];\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  }\n\n  // node hasn't implemented slice on Uint8Array yet\n  const result = new Uint8Array(ifdo);\n  for (let i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n  return result.buffer;\n};\n\nconst encodeImage = (values, width, height, metadata) => {\n  if (height === undefined || height === null) {\n    throw new Error(`you passed into encodeImage a width of type ${height}`);\n  }\n\n  if (width === undefined || width === null) {\n    throw new Error(`you passed into encodeImage a width of type ${width}`);\n  }\n\n  const ifd = {\n    256: [width], // ImageWidth\n    257: [height], // ImageLength\n    273: [numBytesInIfd], // strips offset\n    278: [height], // RowsPerStrip\n    305: 'geotiff.js', // no array for ASCII(Z)\n  };\n\n  if (metadata) {\n    for (const i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n\n  const prfx = new Uint8Array(encodeIfds([ifd]));\n\n  const img = new Uint8Array(values);\n\n  const samplesPerPixel = ifd[277];\n\n  const data = new Uint8Array(numBytesInIfd + (width * height * samplesPerPixel));\n  times(prfx.length, (i) => {\n    data[i] = prfx[i];\n  });\n  forEach(img, (value, i) => {\n    data[numBytesInIfd + i] = value;\n  });\n\n  return data.buffer;\n};\n\nconst convertToTids = (input) => {\n  const result = {};\n  for (const key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n      result[name2code[key]] = input[key];\n    }\n  }\n  return result;\n};\n\nconst toArray = (input) => {\n  if (Array.isArray(input)) {\n    return input;\n  }\n  return [input];\n};\n\nconst metadataDefaults = [\n  ['Compression', 1], // no compression\n  ['PlanarConfiguration', 1],\n  ['XPosition', 0],\n  ['YPosition', 0],\n  ['ResolutionUnit', 1], // Code 1 for actual pixel count or 2 for pixels per inch.\n  ['ExtraSamples', 0], // should this be an array??\n  ['GeoAsciiParams', 'WGS 84\\u0000'],\n  ['ModelTiepoint', [0, 0, 0, -180, 90, 0]], // raster fits whole globe\n  ['GTModelTypeGeoKey', 2],\n  ['GTRasterTypeGeoKey', 1],\n  ['GeographicTypeGeoKey', 4326],\n  ['GeogCitationGeoKey', 'WGS 84'],\n];\n\nexport function writeGeotiff(data, metadata) {\n  const isFlattened = typeof data[0] === 'number';\n\n  let height;\n  let numBands;\n  let width;\n  let flattenedValues;\n\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    times(height, (rowIndex) => {\n      times(width, (columnIndex) => {\n        times(numBands, (bandIndex) => {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width;\n\n  // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = times(numBands, () => 8);\n  }\n\n  metadataDefaults.forEach((tag) => {\n    const key = tag[0];\n    if (!metadata[key]) {\n      const value = tag[1];\n      metadata[key] = value;\n    }\n  });\n\n  // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  }\n\n  // The number of components per pixel.\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = times(numBands, () => 1);\n  }\n\n\n  const geoKeys = Object.keys(metadata)\n    .filter((key) => endsWith(key, 'GeoKey'))\n    .sort((a, b) => name2code[a] - name2code[b]);\n\n  if (!metadata.GeoKeyDirectory) {\n    const NumberOfKeys = geoKeys.length;\n\n    const GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach((geoKey) => {\n      const KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n\n      let Count;\n      let TIFFTagLocation;\n      let valueOffset;\n      if (fieldTagTypes[KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);\n      }\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  }\n\n  // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n  for (const geoKey in geoKeys) {\n    if (geoKeys.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n\n  [\n    'Compression',\n    'ExtraSamples',\n    'GeographicTypeGeoKey',\n    'GTModelTypeGeoKey',\n    'GTRasterTypeGeoKey',\n    'ImageLength', // synonym of ImageHeight\n    'ImageWidth',\n    'PhotometricInterpretation',\n    'PlanarConfiguration',\n    'ResolutionUnit',\n    'SamplesPerPixel',\n    'XPosition',\n    'YPosition',\n  ].forEach((name) => {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n\n\n  const encodedMetadata = convertToTids(metadata);\n\n  const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n\n  return outputImage;\n}\n","\n/**\n * A no-op logger\n */\nclass DummyLogger {\n  log() {}\n\n  info() {}\n\n  warn() {}\n\n  error() {}\n\n  time() {}\n\n  timeEnd() {}\n}\n\nlet LOGGER = new DummyLogger();\n\n/**\n *\n * @param {object} logger the new logger. e.g `console`\n */\nexport function setLogger(logger = new DummyLogger()) {\n  LOGGER = logger;\n}\n\nexport function log(...args) {\n  return LOGGER.log(...args);\n}\n\nexport function info(...args) {\n  return LOGGER.info(...args);\n}\n\nexport function warn(...args) {\n  return LOGGER.warn(...args);\n}\n\nexport function error(...args) {\n  return LOGGER.error(...args);\n}\n\nexport function time(...args) {\n  return LOGGER.time(...args);\n}\n\nexport function timeEnd(...args) {\n  return LOGGER.timeEnd(...args);\n}\n","import GeoTIFFImage from \"./geotiffimage\";\nimport DataView64 from \"./dataview64\";\nimport DataSlice from \"./dataslice\";\nimport { makeBufferSource } from \"./source-rn\";\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from \"./globals\";\nimport { writeGeotiff } from \"./geotiffwriter\";\nimport * as globals from \"./globals\";\nimport * as rgb from \"./rgb\";\nimport { getDecoder } from \"./compression\";\nimport { setLogger } from \"./logging\";\n\nexport { globals };\nexport { rgb };\nexport { getDecoder };\nexport { setLogger };\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE:\n    case fieldTypes.ASCII:\n    case fieldTypes.SBYTE:\n    case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT:\n    case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG:\n    case fieldTypes.SLONG:\n    case fieldTypes.FLOAT:\n    case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL:\n    case fieldTypes.SRATIONAL:\n    case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8:\n    case fieldTypes.SLONG8:\n    case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = rawGeoKeyDirectory[i + 1]\n      ? fieldTagNames[rawGeoKeyDirectory[i + 1]]\n      : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === \"undefined\" || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === \"string\") {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE:\n    case fieldTypes.ASCII:\n    case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count);\n      readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count);\n      readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count);\n      readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count);\n      readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG:\n    case fieldTypes.IFD:\n      values = new Uint32Array(count);\n      readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count);\n      readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8:\n    case fieldTypes.IFD8:\n      values = new Array(count);\n      readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count);\n      readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2);\n      readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2);\n      readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count);\n      readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count);\n      readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (\n    !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)\n  ) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(dataSlice, offset + i * fieldTypeLength);\n    }\n  } else {\n    // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(dataSlice, offset + i * fieldTypeLength);\n      values[i + 1] = readMethod.call(\n        dataSlice,\n        offset + (i * fieldTypeLength + 4)\n      );\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder(\"utf-8\").decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {Object} [options={}] optional parameters\n   * @param {Array} [options.window=whole image] the subset to read data from.\n   * @param {Array} [options.bbox=whole image] the subset to read data from in\n   *                                           geographical coordinates.\n   * @param {Array} [options.samples=all samples] the selection of samples to read from.\n   * @param {Boolean} [options.interleave=false] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {Number} [options.pool=null] The optional decoder pool to use.\n   * @param {Number} [options.width] The desired width of the output. When the width is not the\n   *                                 same as the images, resampling will be performed.\n   * @param {Number} [options.height] The desired height of the output. When the width is not the\n   *                                  same as the images, resampling will be performed.\n   * @param {String} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {Number|Number[]} [options.fillValue] The value to use for parts of the image\n   *                                              outside of the images extent. When multiple\n   *                                              samples are requested, an array of fill values\n   *                                              can be passed.\n   * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + imageWindow[0] * rX,\n          oY + imageWindow[1] * rY,\n          oX + imageWindow[2] * rX,\n          oY + imageWindow[3] * rY,\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error(\"Both width and resX passed\");\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error(\"Both width and resY passed\");\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const {\n          SubfileType: subfileType,\n          NewSubfileType: newSubfileType,\n        } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {Source} source The datasource to read from.\n   * @param {Boolean} littleEndian Whether the image uses little endian.\n   * @param {Boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {Number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {Object} [options] further options.\n   * @param {Boolean} [options.cache=false] whether or not decoded tiles shall be cached.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new DataSlice(\n      await this.source.fetch(\n        offset,\n        typeof size !== \"undefined\" ? size : fallbackSize\n      ),\n      offset,\n      this.littleEndian,\n      this.bigTiff\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {ImageFileDirectory} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = numDirEntries * entrySize + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (\n      let entryCount = 0;\n      entryCount < numDirEntries;\n      i += entrySize, ++entryCount\n    ) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(\n            dataSlice,\n            fieldType,\n            typeCount,\n            actualOffset\n          );\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(\n            fieldDataSlice,\n            fieldType,\n            typeCount,\n            actualOffset\n          );\n        }\n      }\n\n      // unpack single values from the array\n      if (\n        typeCount === 1 &&\n        arrayFields.indexOf(fieldTag) === -1 &&\n        !(\n          fieldType === fieldTypes.RATIONAL ||\n          fieldType === fieldTypes.SRATIONAL\n        )\n      ) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + entrySize * numDirEntries\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {Number} [index=0] the index of the image to return.\n   * @returns {GeoTIFFImage} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new GeoTIFFImage(\n      ifd.fileDirectory,\n      ifd.geoKeyDirectory,\n      this.dataView,\n      this.littleEndian,\n      this.cache,\n      this.source\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Number} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Object} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = \"GDAL_STRUCTURAL_METADATA_SIZE=\";\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (\n      detectionString ===\n      getValues(slice, fieldTypes.ASCII, detectionString.length, offset)\n    ) {\n      const valuesString = getValues(\n        slice,\n        fieldTypes.ASCII,\n        heuristicAreaSize,\n        offset\n      );\n      const firstLine = valuesString.split(\"\\n\")[0];\n      const metadataSize =\n        Number(firstLine.split(\"=\")[1].split(\" \")[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(\n        slice,\n        fieldTypes.ASCII,\n        metadataSize,\n        offset\n      );\n      this.ghostValues = {};\n      fullString\n        .split(\"\\n\")\n        .filter((line) => line.length > 0)\n        .map((line) => line.split(\"=\"))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {source~Source} source The source of data to parse from.\n   * @param {object} options Additional options.\n   */\n  static async fromSource(source, options) {\n    const headerData = await source.fetch(0, 1024);\n    const dataView = new DataView64(headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4d4d) {\n      littleEndian = false;\n    } else {\n      throw new TypeError(\"Invalid byte order value.\");\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error(\"Unsupported offset byte-size.\");\n      }\n    } else {\n      throw new TypeError(\"Invalid magic number.\");\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === \"function\") {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [\n      this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset),\n    ].concat(\n      this.overviewFiles.map((file) =>\n        file.parseFileDirectoryAt(file.firstIFDOffset)\n      )\n    );\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {Number} [index=0] the index of the image to return.\n   * @returns {GeoTIFFImage} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new GeoTIFFImage(\n            ifd.fileDirectory,\n            imageFile.geoKeyDirectory,\n            imageFile.dataView,\n            imageFile.littleEndian,\n            imageFile.cache,\n            imageFile.source\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError(\"Invalid image index\");\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Number} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()].concat(\n      this.overviewFiles.map((file) => file.getImageCount())\n    );\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromArrayBuffer(arrayBuffer) {\n  return GeoTIFF.fromSource(makeBufferSource(arrayBuffer));\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @returns {Promise.<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nexport async function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\n"]}